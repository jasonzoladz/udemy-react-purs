
/**
 *  | This module defines functions for working with prisms.
 */
"use strict";
var Prelude = require("Prelude");
var Control_MonadPlus = require("Control.MonadPlus");
var Data_Either = require("Data.Either");
var Data_Maybe = require("Data.Maybe");
var Data_Profunctor = require("Data.Profunctor");
var Data_Profunctor_Choice = require("Data.Profunctor.Choice");
var Data_Lens_Types_1 = require("Data.Lens.Types");
var Data_Lens_Types_1 = require("Data.Lens.Types");
var Data_Lens_Internal_Market = require("Data.Lens.Internal.Market");
var Data_Lens_Internal_Tagged = require("Data.Lens.Internal.Tagged");
var withPrism = function (l) {
    return function (f) {
        var $10 = l(new Data_Lens_Internal_Market.Market(Prelude.id(Prelude.categoryFn), Data_Either.Right.create));
        return f($10.value0)($10.value1);
    };
};

/**
 *  | Review a value through a `Prism`.
 */
var review = function (p) {
    return function ($14) {
        return Data_Lens_Internal_Tagged.unTagged(p(Data_Lens_Internal_Tagged.Tagged($14)));
    };
};

/**
 *  | Create a `Prism` from a constructor/pattern pair.
 */
var prism = function (to) {
    return function (fro) {
        return function (dictChoice) {
            return function (pab) {
                return Data_Profunctor.dimap(dictChoice["__superclass_Data.Profunctor.Profunctor_0"]())(fro)(Data_Either.either(Prelude.id(Prelude.categoryFn))(Prelude.id(Prelude.categoryFn)))(Data_Profunctor_Choice.right(dictChoice)(Data_Profunctor.rmap(dictChoice["__superclass_Data.Profunctor.Profunctor_0"]())(to)(pab)));
            };
        };
    };
};
var prism$prime = function (to) {
    return function (fro) {
        return function (dictChoice) {
            return prism(to)(function (s) {
                return Data_Maybe.maybe(new Data_Either.Left(s))(Data_Either.Right.create)(fro(s));
            })(dictChoice);
        };
    };
};
var nearly = function (x) {
    return function (f) {
        return function (dictChoice) {
            return prism$prime(Prelude["const"](x))(function ($15) {
                return Control_MonadPlus.guard(Data_Maybe.monadPlusMaybe)(f($15));
            })(dictChoice);
        };
    };
};
var only = function (dictEq) {
    return function (x) {
        return function (dictChoice) {
            return nearly(x)(function (v) {
                return Prelude["=="](dictEq)(v)(x);
            })(dictChoice);
        };
    };
};
var matching = function (l) {
    return withPrism(l)(function (v) {
        return function (f) {
            return f;
        };
    });
};
var is = function (dictBooleanAlgebra) {
    return function (l) {
        return function ($16) {
            return Data_Either.either(Prelude["const"](Prelude.bottom(dictBooleanAlgebra["__superclass_Prelude.Bounded_0"]())))(Prelude["const"](Prelude.top(dictBooleanAlgebra["__superclass_Prelude.Bounded_0"]())))(matching(l)($16));
        };
    };
};
var isn$primet = function (dictBooleanAlgebra) {
    return function (l) {
        return function ($17) {
            return Prelude.not(dictBooleanAlgebra)(is(dictBooleanAlgebra)(l)($17));
        };
    };
};
var clonePrism = function (l) {
    return function (dictChoice) {
        return withPrism(l)(function (x) {
            return function (y) {
                return function (p) {
                    return prism(x)(y)(dictChoice)(p);
                };
            };
        });
    };
};
module.exports = {
    "isn't": isn$primet, 
    is: is, 
    matching: matching, 
    withPrism: withPrism, 
    clonePrism: clonePrism, 
    only: only, 
    nearly: nearly, 
    review: review, 
    "prism'": prism$prime, 
    prism: prism
};
