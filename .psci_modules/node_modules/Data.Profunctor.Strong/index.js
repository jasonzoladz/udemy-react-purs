"use strict";
var Prelude = require("Prelude");
var Data_Profunctor = require("Data.Profunctor");
var Data_Tuple = require("Data.Tuple");

/**
 *  | The `Strong` class extends `Profunctor` with combinators for working with
 *  | product types.
 *  |
 *  | `first` and `second` lift values in a `Profunctor` to act on the first and
 *  | second components of a `Tuple`, respectively.
 */
var Strong = function (__superclass_Data$dotProfunctor$dotProfunctor_0, first, second) {
    this["__superclass_Data.Profunctor.Profunctor_0"] = __superclass_Data$dotProfunctor$dotProfunctor_0;
    this.first = first;
    this.second = second;
};
var strongFn = new Strong(function () {
    return Data_Profunctor.profunctorFn;
}, function (a2b) {
    return function (v) {
        return new Data_Tuple.Tuple(a2b(v.value0), v.value1);
    };
}, Prelude["<$>"](Data_Tuple.functorTuple));

/**
 *  | The `Strong` class extends `Profunctor` with combinators for working with
 *  | product types.
 *  |
 *  | `first` and `second` lift values in a `Profunctor` to act on the first and
 *  | second components of a `Tuple`, respectively.
 */
var second = function (dict) {
    return dict.second;
};

/**
 *  | The `Strong` class extends `Profunctor` with combinators for working with
 *  | product types.
 *  |
 *  | `first` and `second` lift values in a `Profunctor` to act on the first and
 *  | second components of a `Tuple`, respectively.
 */
var first = function (dict) {
    return dict.first;
};

/**
 *  | Compose a value acting on a `Tuple` from two values, each acting on one of
 *  | the components of the `Tuple`.
 */
var $times$times$times = function (dictCategory) {
    return function (dictStrong) {
        return function (l) {
            return function (r) {
                return Prelude[">>>"](dictCategory["__superclass_Prelude.Semigroupoid_0"]())(first(dictStrong)(l))(second(dictStrong)(r));
            };
        };
    };
};

/**
 *  | Compose a value which introduces a `Tuple` from two values, each introducing
 *  | one side of the `Tuple`.
 *  |
 *  | This combinator is useful when assembling values from smaller components,
 *  | because it provides a way to support two different types of output.
 */
var $amp$amp$amp = function (dictCategory) {
    return function (dictStrong) {
        return function (l) {
            return function (r) {
                var split = Data_Profunctor.dimap(dictStrong["__superclass_Data.Profunctor.Profunctor_0"]())(Prelude.id(Prelude.categoryFn))(function (a) {
                    return new Data_Tuple.Tuple(a, a);
                })(Prelude.id(dictCategory));
                return Prelude[">>>"](dictCategory["__superclass_Prelude.Semigroupoid_0"]())(split)($times$times$times(dictCategory)(dictStrong)(l)(r));
            };
        };
    };
};
module.exports = {
    Strong: Strong, 
    "&&&": $amp$amp$amp, 
    "***": $times$times$times, 
    second: second, 
    first: first, 
    strongFn: strongFn
};
