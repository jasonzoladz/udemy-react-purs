"use strict";
var Prelude = require("Prelude");
var Data_Identity = require("Data.Identity");

/**
 *  | Categorical dual of `Traversable`:
 *  |
 *  | - `distribute` is the dual of `sequence` - it zips an
 *  |   arbitrary collection of containers
 *  | - `collect` is the dual of `traverse` - it traverses
 *  |   an arbitrary collection of values
 */
var Distributive = function (__superclass_Prelude$dotFunctor_0, collect, distribute) {
    this["__superclass_Prelude.Functor_0"] = __superclass_Prelude$dotFunctor_0;
    this.collect = collect;
    this.distribute = distribute;
};
var distributiveIdentity = new Distributive(function () {
    return Data_Identity.functorIdentity;
}, function (dictFunctor) {
    return function (f) {
        return function ($7) {
            return Data_Identity.Identity(Prelude.map(dictFunctor)(function ($8) {
                return Data_Identity.runIdentity(f($8));
            })($7));
        };
    };
}, function (dictFunctor) {
    return function ($9) {
        return Data_Identity.Identity(Prelude.map(dictFunctor)(Data_Identity.runIdentity)($9));
    };
});

/**
 *  | Categorical dual of `Traversable`:
 *  |
 *  | - `distribute` is the dual of `sequence` - it zips an
 *  |   arbitrary collection of containers
 *  | - `collect` is the dual of `traverse` - it traverses
 *  |   an arbitrary collection of values
 *  | Default implementation: `distribute = collect id`
 */
var distribute = function (dict) {
    return dict.distribute;
};
var distributiveFunction = new Distributive(function () {
    return Prelude.functorFn;
}, function (dictFunctor) {
    return function (f) {
        return function ($10) {
            return distribute(distributiveFunction)(dictFunctor)(Prelude.map(dictFunctor)(f)($10));
        };
    };
}, function (dictFunctor) {
    return function (a) {
        return function (e) {
            return Prelude.map(dictFunctor)(function (v) {
                return v(e);
            })(a);
        };
    };
});

/**
 *  | Zip an arbitrary collection of containers and summarize the results
 */
var cotraverse = function (dictDistributive) {
    return function (dictFunctor) {
        return function (f) {
            return function ($11) {
                return Prelude.map(dictDistributive["__superclass_Prelude.Functor_0"]())(f)(distribute(dictDistributive)(dictFunctor)($11));
            };
        };
    };
};

/**
 *  | Categorical dual of `Traversable`:
 *  |
 *  | - `distribute` is the dual of `sequence` - it zips an
 *  |   arbitrary collection of containers
 *  | - `collect` is the dual of `traverse` - it traverses
 *  |   an arbitrary collection of values
 *  | Default implementation: `collect f = distribute <<< map f`
 */
var collect = function (dict) {
    return dict.collect;
};
module.exports = {
    Distributive: Distributive, 
    cotraverse: cotraverse, 
    collect: collect, 
    distribute: distribute, 
    distributiveIdentity: distributiveIdentity, 
    distributiveFunction: distributiveFunction
};
