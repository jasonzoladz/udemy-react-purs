
/**
 *  | This module defines functions for working with folds.
 */
"use strict";
var Prelude = require("Prelude");
var Control_Apply = require("Control.Apply");
var Data_Const = require("Data.Const");
var Data_Either = require("Data.Either");
var Data_Foldable = require("Data.Foldable");
var Data_Functor_Contravariant = require("Data.Functor.Contravariant");
var Data_List = require("Data.List");
var Data_Maybe = require("Data.Maybe");
var Data_Maybe_First = require("Data.Maybe.First");
var Data_Maybe_Last = require("Data.Maybe.Last");
var Data_Monoid_Additive = require("Data.Monoid.Additive");
var Data_Monoid_Conj = require("Data.Monoid.Conj");
var Data_Monoid_Disj = require("Data.Monoid.Disj");
var Data_Monoid_Dual = require("Data.Monoid.Dual");
var Data_Monoid_Endo = require("Data.Monoid.Endo");
var Data_Monoid_Multiplicative = require("Data.Monoid.Multiplicative");
var Data_Profunctor = require("Data.Profunctor");
var Data_Profunctor_Choice = require("Data.Profunctor.Choice");
var Data_Profunctor_Star = require("Data.Profunctor.Star");
var Data_Tuple = require("Data.Tuple");
var Data_Lens_Internal_Void = require("Data.Lens.Internal.Void");
var Data_Lens_Types_1 = require("Data.Lens.Types");
var Data_Lens_Types_1 = require("Data.Lens.Types");

/**
 *  | Builds a `Fold` using an unfold.
 */
var unfolded = function (dictApplicative) {
    return function (dictContravariant) {
        return function (f) {
            return function (p) {
                var go = function ($34) {
                    return Data_Maybe.maybe(Data_Lens_Internal_Void.coerce(dictContravariant)((dictApplicative["__superclass_Prelude.Apply_0"]())["__superclass_Prelude.Functor_0"]())(Prelude.pure(dictApplicative)(Prelude.unit)))(function (v) {
                        return Control_Apply["*>"](dictApplicative["__superclass_Prelude.Apply_0"]())(Data_Profunctor_Star.runStar(p)(v.value0))(go(v.value1));
                    })(f($34));
                };
                return go;
            };
        };
    };
};

/**
 *  | Replicates the elements of a fold.
 */
var replicated = function (dictApplicative) {
    return function (dictContravariant) {
        return function (n) {
            return function (p) {
                var go = function (x) {
                    return function (v) {
                        if (v === 0) {
                            return Data_Lens_Internal_Void.coerce(dictContravariant)((dictApplicative["__superclass_Prelude.Apply_0"]())["__superclass_Prelude.Functor_0"]())(Prelude.pure(dictApplicative)(Prelude.unit));
                        };
                        return Control_Apply["*>"](dictApplicative["__superclass_Prelude.Apply_0"]())(x)(go(x)(v - 1));
                    };
                };
                return function ($35) {
                    return Prelude.flip(go)(n)(Data_Profunctor_Star.runStar(p)($35));
                };
            };
        };
    };
};

/**
 *  | Folds over a `Foldable` container.
 */
var folded = function (dictApplicative) {
    return function (dictContravariant) {
        return function (dictFoldable) {
            return function (p) {
                return Data_Profunctor_Star.Star(Data_Foldable.foldr(dictFoldable)(function (a) {
                    return function (r) {
                        return Control_Apply["*>"](dictApplicative["__superclass_Prelude.Apply_0"]())(Data_Profunctor_Star.runStar(p)(a))(r);
                    };
                })(Data_Lens_Internal_Void.coerce(dictContravariant)((dictApplicative["__superclass_Prelude.Apply_0"]())["__superclass_Prelude.Functor_0"]())(Prelude.pure(dictApplicative)(Prelude.unit))));
            };
        };
    };
};

/**
 *  | Folds all foci of a `Fold` to one. Note that this is the same as `view`.
 */
var foldOf = function (p) {
    return function ($36) {
        return Data_Const.getConst(Data_Profunctor_Star.runStar(p(Data_Const.Const))($36));
    };
};

/**
 *  | Maps and then folds all foci of a `Fold`.
 */
var foldMapOf = function (p) {
    return function (f) {
        return function ($37) {
            return Data_Const.getConst(Data_Profunctor_Star.runStar(p(function ($38) {
                return Data_Const.Const(f($38));
            }))($37));
        };
    };
};

/**
 *  | Left fold over a `Fold`.
 */
var foldlOf = function (p) {
    return function (f) {
        return function (r) {
            return function ($39) {
                return Prelude.flip(Data_Monoid_Endo.runEndo)(r)(Data_Monoid_Dual.runDual(foldMapOf(p)(function ($40) {
                    return Data_Monoid_Dual.Dual(Data_Monoid_Endo.Endo(Prelude.flip(f)($40)));
                })($39)));
            };
        };
    };
};

/**
 *  | Right fold over a `Fold`.
 */
var foldrOf = function (p) {
    return function (f) {
        return function (r) {
            return function ($41) {
                return Prelude.flip(Data_Monoid_Endo.runEndo)(r)(foldMapOf(p)(function ($42) {
                    return Data_Monoid_Endo.Endo(f($42));
                })($41));
            };
        };
    };
};

/**
 *  | The maximum of all foci of a `Fold`, if there is any.
 */
var maximumOf = function (dictOrd) {
    return function (p) {
        var max = function (a) {
            return function (b) {
                var $30 = Prelude[">"](dictOrd)(a)(b);
                if ($30) {
                    return a;
                };
                if (!$30) {
                    return b;
                };
                throw new Error("Failed pattern match at Data.Lens.Fold line 112, column 13 - line 115, column 1: " + [ $30.constructor.name ]);
            };
        };
        return foldrOf(p)(function (a) {
            return function ($43) {
                return Data_Maybe.Just.create(Data_Maybe.maybe(a)(max(a))($43));
            };
        })(Data_Maybe.Nothing.value);
    };
};

/**
 *  | The minimum of all foci of a `Fold`, if there is any.
 */
var minimumOf = function (dictOrd) {
    return function (p) {
        var min = function (a) {
            return function (b) {
                var $31 = Prelude[">"](dictOrd)(a)(b);
                if ($31) {
                    return a;
                };
                if (!$31) {
                    return b;
                };
                throw new Error("Failed pattern match at Data.Lens.Fold line 117, column 13 - line 120, column 1: " + [ $31.constructor.name ]);
            };
        };
        return foldrOf(p)(function (a) {
            return function ($44) {
                return Data_Maybe.Just.create(Data_Maybe.maybe(a)(min(a))($44));
            };
        })(Data_Maybe.Nothing.value);
    };
};

/**
 *  | Collects the foci of a `Fold` into a list.
 */
var toListOf = function (p) {
    return foldrOf(p)(Data_List[":"])(Data_List.Nil.value);
};

/**
 *  | Synonym for `toListOf`, reversed.
 */
var $up$dot$dot = function (s) {
    return function (p) {
        return toListOf(p)(s);
    };
};

/**
 *  | Determines whether a `Fold` has at least one focus.
 */
var has = function (dictBooleanAlgebra) {
    return function (p) {
        return function ($45) {
            return Data_Monoid_Disj.runDisj(foldMapOf(p)(Prelude["const"](Prelude.top(dictBooleanAlgebra["__superclass_Prelude.Bounded_0"]())))($45));
        };
    };
};

/**
 *  | Determines whether a `Fold` does not have a focus.
 */
var hasn$primet = function (dictBooleanAlgebra) {
    return function (p) {
        return function ($46) {
            return Data_Monoid_Conj.runConj(foldMapOf(p)(Prelude["const"](Prelude.bottom(dictBooleanAlgebra["__superclass_Prelude.Bounded_0"]())))($46));
        };
    };
};

/**
 *  | The last focus of a `Fold`, if there is any.
 */
var lastOf = function (p) {
    return function ($47) {
        return Data_Maybe_Last.runLast(foldMapOf(p)(function ($48) {
            return Data_Maybe_Last.Last(Data_Maybe.Just.create($48));
        })($47));
    };
};

/**
 *  | The number of foci of a `Fold`.
 */
var lengthOf = function (p) {
    return function ($49) {
        return Data_Monoid_Additive.runAdditive(foldMapOf(p)(Prelude["const"](1))($49));
    };
};

/**
 *  | Previews the first value of a fold, if there is any.
 */
var preview = function (p) {
    return function ($50) {
        return Data_Maybe_First.runFirst(foldMapOf(p)(function ($51) {
            return Data_Maybe_First.First(Data_Maybe.Just.create($51));
        })($50));
    };
};

/**
 *  | Synonym for `preview`, flipped.
 */
var $up$qmark = function (s) {
    return function (p) {
        return preview(p)(s);
    };
};

/**
 *  | The product of all foci of a `Fold`.
 */
var productOf = function (dictSemiring) {
    return function (p) {
        return function ($52) {
            return Data_Monoid_Multiplicative.runMultiplicative(foldMapOf(p)(Data_Monoid_Multiplicative.Multiplicative)($52));
        };
    };
};

/**
 *  | Sequence the foci of a `Fold`, pulling out an `Applicative`, and ignore
 *  | the result. If you need the result, see `sequenceOf` for `Traversal`s.
 */
var sequenceOf_ = function (dictApplicative) {
    return function (p) {
        return function ($53) {
            return Prelude.flip(Data_Monoid_Endo.runEndo)(Prelude.pure(dictApplicative)(Prelude.unit))(foldMapOf(p)(function (f) {
                return Control_Apply["*>"](dictApplicative["__superclass_Prelude.Apply_0"]())(f);
            })($53));
        };
    };
};

/**
 *  | The sum of all foci of a `Fold`.
 */
var sumOf = function (dictSemiring) {
    return function (p) {
        return function ($54) {
            return Data_Monoid_Additive.runAdditive(foldMapOf(p)(Data_Monoid_Additive.Additive)($54));
        };
    };
};

/**
 *  | The first focus of a `Fold`, if there is any. Synonym for `preview`.
 */
var firstOf = function (p) {
    return function ($55) {
        return Data_Maybe_First.runFirst(foldMapOf(p)(function ($56) {
            return Data_Maybe_First.First(Data_Maybe.Just.create($56));
        })($55));
    };
};

/**
 *  | Find the first focus of a `Fold` that satisfies a predicate, if there is any.
 */
var findOf = function (p) {
    return function (f) {
        return foldrOf(p)(function (a) {
            return Data_Maybe.maybe((function () {
                var $32 = f(a);
                if ($32) {
                    return new Data_Maybe.Just(a);
                };
                if (!$32) {
                    return Data_Maybe.Nothing.value;
                };
                throw new Error("Failed pattern match at Data.Lens.Fold line 121, column 38 - line 121, column 69: " + [ $32.constructor.name ]);
            })())(Data_Maybe.Just.create);
        })(Data_Maybe.Nothing.value);
    };
};

/**
 *  | Filters on a predicate.
 */
var filtered = function (dictChoice) {
    return function (f) {
        return function ($57) {
            return Data_Profunctor.dimap(dictChoice["__superclass_Data.Profunctor.Profunctor_0"]())(function (x) {
                var $33 = f(x);
                if ($33) {
                    return new Data_Either.Right(x);
                };
                if (!$33) {
                    return new Data_Either.Left(x);
                };
                throw new Error("Failed pattern match at Data.Lens.Fold line 146, column 27 - line 146, column 58: " + [ $33.constructor.name ]);
            })(Data_Either.either(Prelude.id(Prelude.categoryFn))(Prelude.id(Prelude.categoryFn)))(Data_Profunctor_Choice.right(dictChoice)($57));
        };
    };
};

/**
 *  | Whether any focus of a `Fold` satisfies a predicate.
 */
var anyOf = function (dictBooleanAlgebra) {
    return function (p) {
        return function (f) {
            return function ($58) {
                return Data_Monoid_Disj.runDisj(foldMapOf(p)(function ($59) {
                    return Data_Monoid_Disj.Disj(f($59));
                })($58));
            };
        };
    };
};

/**
 *  | Whether a `Fold` contains a given element.
 */
var elemOf = function (dictEq) {
    return function (p) {
        return function (a) {
            return anyOf(Prelude.booleanAlgebraBoolean)(p)(function (v) {
                return Prelude["=="](dictEq)(v)(a);
            });
        };
    };
};

/**
 *  | The disjunction of all foci of a `Fold`.
 */
var orOf = function (dictBooleanAlgebra) {
    return function (p) {
        return anyOf(dictBooleanAlgebra)(p)(Prelude.id(Prelude.categoryFn));
    };
};

/**
 *  | Whether all foci of a `Fold` satisfy a predicate.
 */
var allOf = function (dictBooleanAlgebra) {
    return function (p) {
        return function (f) {
            return function ($60) {
                return Data_Monoid_Conj.runConj(foldMapOf(p)(function ($61) {
                    return Data_Monoid_Conj.Conj(f($61));
                })($60));
            };
        };
    };
};

/**
 *  | The conjunction of all foci of a `Fold`.
 */
var andOf = function (dictBooleanAlgebra) {
    return function (p) {
        return allOf(dictBooleanAlgebra)(p)(Prelude.id(Prelude.categoryFn));
    };
};

/**
 *  | Whether a `Fold` not contains a given element.
 */
var notElemOf = function (dictEq) {
    return function (p) {
        return function (a) {
            return allOf(Prelude.booleanAlgebraBoolean)(p)(function (v) {
                return Prelude["/="](dictEq)(v)(a);
            });
        };
    };
};
module.exports = {
    filtered: filtered, 
    replicated: replicated, 
    "hasn't": hasn$primet, 
    has: has, 
    sequenceOf_: sequenceOf_, 
    findOf: findOf, 
    lengthOf: lengthOf, 
    productOf: productOf, 
    sumOf: sumOf, 
    notElemOf: notElemOf, 
    elemOf: elemOf, 
    orOf: orOf, 
    andOf: andOf, 
    anyOf: anyOf, 
    allOf: allOf, 
    minimumOf: minimumOf, 
    maximumOf: maximumOf, 
    lastOf: lastOf, 
    firstOf: firstOf, 
    toListOf: toListOf, 
    foldlOf: foldlOf, 
    foldrOf: foldrOf, 
    foldMapOf: foldMapOf, 
    foldOf: foldOf, 
    preview: preview, 
    "^..": $up$dot$dot, 
    "^?": $up$qmark
};
